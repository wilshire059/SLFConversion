
/**
 * Migrate BlendListByEnum nodes from Blueprint enum to C++ enum
 * This properly replaces nodes: saves connections, clears enum, sets new enum, reconstructs, restores connections
 */
int32 USLFAutomationLibrary::MigrateBlendListByEnumToCpp(UObject* AnimBlueprintAsset, const FString& OldEnumPath, const FString& NewEnumPath)
{
	if (!AnimBlueprintAsset) return 0;

	UAnimBlueprint* AnimBP = Cast<UAnimBlueprint>(AnimBlueprintAsset);
	if (!AnimBP)
	{
		UBlueprint* BP = Cast<UBlueprint>(AnimBlueprintAsset);
		if (BP && BP->GeneratedClass)
		{
			AnimBP = Cast<UAnimBlueprint>(BP);
		}
	}
	if (!AnimBP) return 0;

	UE_LOG(LogSLFAutomation, Warning, TEXT("=== MigrateBlendListByEnumToCpp ==="));
	UE_LOG(LogSLFAutomation, Warning, TEXT("  Old enum: %s"), *OldEnumPath);
	UE_LOG(LogSLFAutomation, Warning, TEXT("  New enum: %s"), *NewEnumPath);

	// Load the new C++ enum
	UEnum* NewEnum = FindObject<UEnum>(nullptr, *NewEnumPath);
	if (!NewEnum)
	{
		// Try loading it
		NewEnum = LoadObject<UEnum>(nullptr, *NewEnumPath);
	}
	if (!NewEnum)
	{
		UE_LOG(LogSLFAutomation, Error, TEXT("  Failed to find new enum: %s"), *NewEnumPath);
		return 0;
	}
	UE_LOG(LogSLFAutomation, Warning, TEXT("  Found new enum: %s with %d entries"), *NewEnum->GetName(), NewEnum->NumEnums());

	// Load the old enum for comparison
	UEnum* OldEnum = FindObject<UEnum>(nullptr, *OldEnumPath);
	if (!OldEnum)
	{
		OldEnum = LoadObject<UEnum>(nullptr, *OldEnumPath);
	}

	int32 MigratedCount = 0;

	// Get ALL graphs including AnimGraph and LinkedAnimLayer graphs
	TArray<UEdGraph*> AllGraphs;
	AllGraphs.Append(AnimBP->FunctionGraphs);

	// Also check UbergraphPages for AnimGraph
	for (UEdGraph* Graph : AnimBP->UbergraphPages)
	{
		if (Graph)
		{
			AllGraphs.Add(Graph);
		}
	}

	for (UEdGraph* Graph : AllGraphs)
	{
		if (!Graph) continue;

		UE_LOG(LogSLFAutomation, Warning, TEXT("  Checking graph: %s"), *Graph->GetName());

		// Find BlendListByEnum nodes
		for (UEdGraphNode* Node : Graph->Nodes)
		{
			if (!Node) continue;
			if (!Node->GetClass()->GetName().Contains(TEXT("BlendListByEnum"))) continue;

			// Cast to the specific type
			UAnimGraphNode_BlendListByEnum* BlendNode = Cast<UAnimGraphNode_BlendListByEnum>(Node);
			if (!BlendNode) continue;

			// Check if this node uses the old enum
			UEnum* BoundEnum = BlendNode->GetEnum();
			if (!BoundEnum) continue;

			FString BoundEnumPath = BoundEnum->GetPathName();
			if (!BoundEnumPath.Equals(OldEnumPath, ESearchCase::IgnoreCase))
			{
				UE_LOG(LogSLFAutomation, Warning, TEXT("    Node %s uses different enum: %s"), *Node->GetName(), *BoundEnumPath);
				continue;
			}

			UE_LOG(LogSLFAutomation, Warning, TEXT("    Migrating node: %s at (%d, %d)"), *Node->GetName(), Node->NodePosX, Node->NodePosY);

			// Step 1: Save all pin connections
			struct FPinConnection
			{
				FName PinName;
				TArray<TPair<UEdGraphNode*, FName>> LinkedPins; // Node + PinName pairs
			};
			TArray<FPinConnection> SavedConnections;

			for (UEdGraphPin* Pin : Node->Pins)
			{
				if (!Pin) continue;

				FPinConnection Conn;
				Conn.PinName = Pin->PinName;

				for (UEdGraphPin* LinkedPin : Pin->LinkedTo)
				{
					if (LinkedPin && LinkedPin->GetOwningNode())
					{
						Conn.LinkedPins.Add(TPair<UEdGraphNode*, FName>(LinkedPin->GetOwningNode(), LinkedPin->PinName));
					}
				}

				if (Conn.LinkedPins.Num() > 0)
				{
					SavedConnections.Add(Conn);
					UE_LOG(LogSLFAutomation, Warning, TEXT("      Saved %d connections for pin: %s"), Conn.LinkedPins.Num(), *Pin->PinName.ToString());
				}
			}

			// Step 2: Get visible enum entries before clearing
			TArray<FName> VisibleEntries;
			// The VisibleEnumEntries is protected, but we can infer from pins
			// Enum entries correspond to pose pins: BlendPose_1, BlendPose_2, etc.
			for (UEdGraphPin* Pin : Node->Pins)
			{
				if (Pin && Pin->PinName.ToString().StartsWith(TEXT("BlendPose_")))
				{
					// Extract index from pin name
					FString IndexStr = Pin->PinName.ToString().RightChop(10); // Remove "BlendPose_"
					int32 PinIndex = FCString::Atoi(*IndexStr);

					// BlendPose_0 is "Default", BlendPose_1+ are enum entries
					if (PinIndex > 0 && OldEnum)
					{
						int32 EnumIndex = PinIndex - 1;
						if (EnumIndex < OldEnum->NumEnums() - 1) // -1 for _MAX
						{
							FName EntryName = OldEnum->GetNameByIndex(EnumIndex);
							VisibleEntries.Add(EntryName);
							UE_LOG(LogSLFAutomation, Warning, TEXT("      Visible entry %d: %s"), EnumIndex, *EntryName.ToString());
						}
					}
				}
			}

			// Step 3: Use ReloadEnum to change the enum type
			// This is the same method the editor uses
			BlendNode->ReloadEnum(NewEnum);

			// Step 4: Reconstruct the node with new pins
			BlendNode->ReconstructNode();

			// Step 5: Restore connections
			for (const FPinConnection& Conn : SavedConnections)
			{
				UEdGraphPin* Pin = Node->FindPin(Conn.PinName);
				if (!Pin)
				{
					UE_LOG(LogSLFAutomation, Warning, TEXT("      Could not find pin %s after reconstruction"), *Conn.PinName.ToString());
					continue;
				}

				for (const TPair<UEdGraphNode*, FName>& LinkedPinInfo : Conn.LinkedPins)
				{
					UEdGraphNode* OtherNode = LinkedPinInfo.Key;
					UEdGraphPin* OtherPin = OtherNode ? OtherNode->FindPin(LinkedPinInfo.Value) : nullptr;

					if (OtherPin)
					{
						Pin->MakeLinkTo(OtherPin);
						UE_LOG(LogSLFAutomation, Warning, TEXT("      Restored connection: %s -> %s.%s"),
							*Conn.PinName.ToString(), *OtherNode->GetName(), *LinkedPinInfo.Value.ToString());
					}
				}
			}

			MigratedCount++;
		}
	}

	if (MigratedCount > 0)
	{
		FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(AnimBP);
		FKismetEditorUtilities::CompileBlueprint(AnimBP, EBlueprintCompileOptions::SkipGarbageCollection);

		// Save
		UEditorAssetLibrary::SaveAsset(AnimBP->GetPathName(), false);
	}

	UE_LOG(LogSLFAutomation, Warning, TEXT("=== Migrated %d BlendListByEnum nodes ==="), MigratedCount);
	return MigratedCount;
}

